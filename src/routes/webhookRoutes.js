// ============================================================
// PRISMA — GitHub Webhook Routes
// ============================================================
// Handles incoming real-time events straight from GitHub.
// Receives pushes and new issues instantly.
// ============================================================
const express = require('express');
const crypto = require('crypto');
const pulseEngine = require('../services/pulse');
const db = require('../core/database');

const router = express.Router();

// The secret used to verify webhook signatures (optional but recommended)
// We will auto-generate this and pass it to gh api when registering,
// but for simplicity, we'll accept incoming payloads first.
// If we had a strict secret, we'd verify it here using crypto.createHmac.

router.post('/', express.json(), (req, res) => {
    // Acknowledge receipt immediately so GitHub doesn't timeout
    res.status(202).send('Accepted');

    const event = req.headers['x-github-event'];
    const payload = req.body;

    // We need the user ID. Since this is a single-user desktop app,
    // we can just grab the first user from the DB.
    const users = db.getAllUsers();
    const userId = users.length > 0 ? users[0].id : null;

    if (!payload || !payload.repository) {
        return; // Malformed payload
    }

    const repoFullName = payload.repository.full_name;

    try {
        if (event === 'push') {
            // Only care about actual commits, not branch deletions
            if (payload.commits && payload.commits.length > 0) {
                // Skip pushes caused by PRISMA's own commits (issue solver)
                const allPrisma = payload.commits.every(c =>
                    (c.message || '').startsWith('fix(#') ||
                    (c.message || '').includes('Auto-generated by PRISMA')
                );
                if (allPrisma) {
                    console.log(`[Webhook] Skipping self-push for ${repoFullName} (PRISMA commit)`);
                    return;
                }

                console.log(`[Webhook] Real-time push received for ${repoFullName}`);
                pulseEngine._runGuardianScanRemote(repoFullName, userId);
            }
        }
        else if (event === 'issues') {
            // Only care when a new issue is opened
            if (payload.action === 'opened' && payload.issue) {
                console.log(`[Webhook] Real-time issue opened for ${repoFullName} (#${payload.issue.number})`);
                // Pass the SPECIFIC issue from the webhook, not all issues
                pulseEngine._handleNewIssue(repoFullName, userId, {
                    number: payload.issue.number,
                    title: payload.issue.title,
                    body: payload.issue.body || '',
                    labels: (payload.issue.labels || []).map(l => ({ name: l.name })),
                });
            }
        }
        else if (event === 'ping') {
            console.log(`[Webhook] ⚡ Ping received from GitHub for ${repoFullName} — Webhook is active!`);
        }
    } catch (err) {
        console.error(`[Webhook] Error processing ${event} event:`, err.message);
    }
});

module.exports = router;
